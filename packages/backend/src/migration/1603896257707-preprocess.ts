import { MigrationInterface, QueryRunner } from "typeorm";

export class preprocess1603896257707 implements MigrationInterface {

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`CREATE OR REPLACE FUNCTION convert_to_integer(v_input text) RETURNS INTEGER AS $$ DECLARE v_int_value INTEGER DEFAULT NULL; BEGIN BEGIN v_int_value := v_input::INTEGER; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; RETURN v_int_value; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE FUNCTION convert_to_float(v_input text) RETURNS FLOAT AS $$ DECLARE v_int_value FLOAT DEFAULT NULL; BEGIN BEGIN v_int_value := v_input::FLOAT; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; RETURN v_int_value; END; $$ LANGUAGE plpgsql;`, undefined);
        await queryRunner.query(`INSERT INTO nodes (id, lat, lon, osmid, highway, geom, uuid) OVERRIDING SYSTEM VALUE SELECT b.ogc_fid, b.x, b.y, b.osmid::bigint, b.highway, b.geom, md5(ROW(b.geom, b.osmid, b.highway)::TEXT)::uuid FROM osmdata.osm_nodes b ON CONFLICT (osmid) DO UPDATE SET (lat, lon, highway, geom, uuid) = (EXCLUDED.lat, EXCLUDED.lon, EXCLUDED.highway, EXCLUDED.geom, md5(ROW(EXCLUDED.geom, EXCLUDED.osmid, EXCLUDED.highway)::TEXT)::uuid );`, undefined);
        await queryRunner.query(`INSERT INTO edges (id, source, target, key, osmid, name, length, width, surface, incline, smoothness, crossing, lit, tactile_paving, wheelchair, handrail, description, step_count, sidewalk, footway, foot, kerb, bicycle, cycleway, highway, access, oneway, service, maxspeed, noexit, horse, tracktype, bridge, tunnel, layer, vehicle, motor_vehicle, motorcycle, railway, train, geom, uuid) OVERRIDING SYSTEM VALUE SELECT b.ogc_fid, b."from"::bigint, b."to"::bigint, b.key::smallint, b.osmid::bigint, b.name, b.length::float, convert_to_float(b.width), b.surface, b.incline, b.smoothness, b.crossing, b.lit, b.tactile_paving, b.wheelchair, b.handrail, b.description, convert_to_integer(b.step_count), b.sidewalk, b.footway, b.foot, b.kerb, b.bicycle, b.cycleway, b.highway, b.access, b.oneway, b.service, b.maxspeed, b.noexit, b.horse, b.tracktype, b.bridge, b.tunnel, b.layer, b.vehicle, b.motor_vehicle, b.motorcycle, b.railway, b.train, b.geom, md5(ROW(b.name, b.key::smallint, b.geom, b.osmid, b.highway, b.oneway, b.maxspeed )::TEXT)::uuid FROM osmdata.osm_edges b ON CONFLICT (id) DO UPDATE SET (source, target, key, name, length, width, surface, incline, smoothness, crossing, lit, tactile_paving, wheelchair, handrail, description, step_count, sidewalk, footway, foot, kerb, bicycle, cycleway, highway, access, oneway, service, maxspeed, noexit, horse, tracktype, bridge, tunnel, layer, vehicle, motor_vehicle, motorcycle, railway, train, geom, uuid) = (EXCLUDED.source, EXCLUDED.target, EXCLUDED.key::smallint, EXCLUDED.name, EXCLUDED.length, EXCLUDED.width, EXCLUDED.surface, EXCLUDED.incline, EXCLUDED.smoothness, EXCLUDED.crossing, EXCLUDED.lit, EXCLUDED.tactile_paving, EXCLUDED.wheelchair, EXCLUDED.handrail, EXCLUDED.description, convert_to_integer(EXCLUDED.step_count), EXCLUDED.sidewalk, EXCLUDED.footway, EXCLUDED.foot, EXCLUDED.kerb, EXCLUDED.bicycle, EXCLUDED.cycleway, EXCLUDED.highway, EXCLUDED.access, EXCLUDED.oneway, EXCLUDED.service, EXCLUDED.maxspeed, EXCLUDED.noexit, EXCLUDED.horse, EXCLUDED.tracktype, EXCLUDED.bridge, EXCLUDED.tunnel, EXCLUDED.layer, EXCLUDED.vehicle, EXCLUDED.motor_vehicle, EXCLUDED.motorcycle, EXCLUDED.railway, EXCLUDED.train, EXCLUDED.geom, md5(ROW(EXCLUDED.name, EXCLUDED.key::smallint, EXCLUDED.geom, EXCLUDED.osmid, EXCLUDED.highway, EXCLUDED.oneway, EXCLUDED.maxspeed )::TEXT)::uuid);`, undefined);
        await queryRunner.query(`CREATE INDEX IF NOT EXISTS modos_edges_geom_idx ON edges USING GIST (geom);`, undefined);
        await queryRunner.query(`CREATE INDEX IF NOT EXISTS modos_nodes_geom_idx ON nodes USING GIST (geom);`, undefined);
        await queryRunner.query(`CREATE INDEX IF NOT EXISTS smdata_edges_geom_idx ON osmdata.osm_edges USING GIST (geom);`, undefined);
        await queryRunner.query(`CREATE INDEX IF NOT EXISTS osmdata_nodes_geom_idx ON osmdata.osm_nodes USING GIST (geom);`, undefined);
        await queryRunner.query(`DROP MATERIALIZED VIEW IF EXISTS network_convex_hull_v;`, undefined);
        await queryRunner.query(`CREATE MATERIALIZED VIEW network_convex_hull_v AS ( SELECT 1::INTEGER AS id, ST_Multi(ST_Transform(ST_Buffer(ST_Transform(ST_ConvexHull(ST_Collect(geom)), 2056), 100), 4326))::geometry(MultiPolygon, 4326) AS geom FROM edges);`, undefined);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        throw new Error("This migration cannot be reversed.");
    }

}
